# ---------------------------------------------------------------------------------------
#   @parent     : github workflow
#   @desc       : checks each issue / PR for a valid label
#   @author     : Aetherinox
#   @url        : https://github.com/Aetherinox
#
#   This Github action must be activated manually.  This workflow script will do the
#   following:
#
#       - Scan issues / pull requests and make sure they have properly assigned labels:
#           - `Bug`
#           - `Feature`
#           - `Urgent`
#           - `Roadmap`
#
#       - Workflow script will then scan each pr or issue and mark them as `Stale`
#         if they haven't had any replies in 30 days.
#
#       - Workflow will `autoclose` pr or issues which haven't had action in `365 days`.
# ---------------------------------------------------------------------------------------

name: "üé´ Issues ‚Ä∫ Stale"
run-name: "üé´ Issues ‚Ä∫ Stale"

# ---------------------------------------------------------------------------------------
#   triggers
# ---------------------------------------------------------------------------------------

on:
  workflow_dispatch:
  schedule:
    - cron: "0 */2 * * *"

# ---------------------------------------------------------------------------------------
#   environment variables
# ---------------------------------------------------------------------------------------

env:
  PREFIX_BUG:           "Bug"
  PREFIX_DEPENDENCY:    "Dependency"
  PREFIX_DOCS:          "Docs"
  PREFIX_FEATURE:       "Feature"
  PREFIX_GIT:           "Git Action"
  PREFIX_PR:            "PR"
  PREFIX_ROADMAP:       "Roadmap"
  PREFIX_INTERNAL:      "Internal"
  PREFIX_URGENT:        "Urgent"

  LABEL_BUG:            "Type ‚ó¶ Bug"
  LABEL_DEPENDENCY:     "Type ‚ó¶ Dependency"
  LABEL_DOCS:           "Type ‚ó¶ Docs"
  LABEL_FEATURE:        "Type ‚ó¶ Feature"
  LABEL_GIT:            "Type ‚ó¶ Git Action"
  LABEL_PR:             "Type ‚ó¶ Pull Request"
  LABEL_ROADMAP:        "Type ‚ó¶ Roadmap"
  LABEL_INTERNAL:       "Type ‚ó¶ Internal"
  LABEL_URGENT:         "‚ö† Urgent"

  ASSIGN_USER:          Aetherinox
  BOT_NAME_1:           AdminServ
  BOT_NAME_2:           AdminServX
  BOT_NAME_3:           EuropaServ
  BOT_NAME_DEPENDABOT:  dependabot[bot]
  LABELS_JSON: |
    [
      { "name": "AC ‚ú¶ Changes Made",           "color": "8F1784", "description": "Requested changes have been made and are pending a re-scan" },
      { "name": "AC ‚ú¶ Changes Required",       "color": "8F1784", "description": "Requires changes to be made to the package before being accepted" },
      { "name": "AC ‚ú¶ Failed",                 "color": "a61f2d", "description": "Autocheck failed to run through a complete cycle, requires investigation" },
      { "name": "AC ‚ú¶ Needs Rebase",           "color": "8F1784", "description": "Due to the permissions on the requesting repo, this pull request must be rebased by the author" },
      { "name": "AC ‚ú¶ Passed",                 "color": "146b4a", "description": "Ready to be reviewed" },
      { "name": "AC ‚ú¶ Review Required",        "color": "8F1784", "description": "PR needs to be reviewed by another person, after the requested changes have been made" },
      { "name": "AC ‚ú¶ Security Warning",       "color": "761620", "description": "Does not conform to developer policies, or includes potentially dangerous code" },
      { "name": "AC ‚ú¶ Skipped Scan",           "color": "8F1784", "description": "Author has skipped code scan" },
      { "name": "Status êÑÇ Duplicate",          "color": "75536b", "description": "Issue or pull request already exists" },
      { "name": "Status êÑÇ Accepted",            "color": "2e7539", "description": "This pull request has been accepted" },
      { "name": "Status êÑÇ Autoclosed",          "color": "3E0915", "description": "Originally stale and was autoclosed for no activity" },
      { "name": "Status êÑÇ Denied",              "color": "ba4058", "description": "Pull request has been denied" },
      { "name": "Status êÑÇ Locked",              "color": "550F45", "description": "Automatically locked by AdminServ for a prolonged period of inactivity" },
      { "name": "Status êÑÇ Need Info",           "color": "2E3C4C", "description": "Not enough information to resolve" },
      { "name": "Status êÑÇ No Action",           "color": "030406", "description": "Closed without any action being taken" },
      { "name": "Status êÑÇ Pending",             "color": "984b12", "description": "Pending pull request" },
      { "name": "Status êÑÇ Released",            "color": "1b6626", "description": "Issues or PR has been implemented and is now live" },
      { "name": "Status êÑÇ Reopened",            "color": "8a6f14", "description": "A previously closed PR which has been re-opened" },
      { "name": "Status êÑÇ Review",              "color": "9e1451", "description": "Currently pending review" },
      { "name": "Status êÑÇ Stale",               "color": "928282", "description": "Has not had any activity in over 30 days" },
      { "name": "Type ‚ó¶ Bug",                   "color": "9a2c2c", "description": "Something isn't working" },
      { "name": "Type ‚ó¶ Dependency",            "color": "243759", "description": "Item is associated to dependency" },
      { "name": "Type ‚ó¶ Docs",                  "color": "0e588d", "description": "Improvements or modifications to docs" },
      { "name": "Type ‚ó¶ Feature",               "color": "3c4e93", "description": "Feature request" },
      { "name": "Type ‚ó¶ Git Action",            "color": "030406", "description": "GitHub Action / workflow" },
      { "name": "Type ‚ó¶ Pull Request",          "color": "8F1784", "description": "Normal pull request" },
      { "name": "Type ‚ó¶ Roadmap",               "color": "8F1784", "description": "Feature or bug currently planned for implementation" },
      { "name": "‚ö† Urgent",                    "color": "a8740e", "description": "Requires urgent attention" }
    ]

jobs:

  # ---------------------------------------------------------------------------------------
  #   Verify Existing Labels
  #   This job will ensure you have labels already created in your repo.
  #
  #   All labels come from the JSON table LABELS_JSON.
  # ---------------------------------------------------------------------------------------

  issues-labels-create:
    name: "üé´ Labels ‚Ä∫ Verify Existing"
    runs-on: ubuntu-latest
    steps:

      - name: "‚úÖ Start"
        run: |
              echo "Assigning labels and assignees"

      # ---------------------------------------------------------------------------------------
      #   checkout
      # ---------------------------------------------------------------------------------------

      - name: "‚òëÔ∏è Checkout"
        id: issues-labels-create-checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------------------------------------------------------------------
      #   Check if repo has labels currently added to issues
      # ---------------------------------------------------------------------------------------

      - name: "üè∑Ô∏è Verify Existing Labels"
        id: issues-labels-create-verify
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMINSERV_TOKEN_CL }}
          script: |
            const labels = JSON.parse( process.env.LABELS_JSON );
            for ( const label of labels )
            {
                try
                {
                    await github.rest.issues.createLabel(
                    {
                        owner:        context.repo.owner,
                        repo:         context.repo.repo,
                        name:         label.name,
                        description:  label.description || '',
                        color:        label.color
                    });
                }
                catch ( err )
                {
                    if ( err.status === 422 )
                    {
                        console.log( `Label '${label.name}' already exists. Skipping.` );
                    }
                    else
                    {
                        console.error( `Error creating label '${label.name}': ${err}` );
                    }
                }
            }

  # ---------------------------------------------------------------------------------------
  #   Runs through all submissions to check for ones that have not been properly labeled
  #       - Bug
  #       - Feature
  #       - Urgent
  #       - Roadmap
  # ---------------------------------------------------------------------------------------

  issues-labels-check:
    name: "üé´ Labels ‚Ä∫ Assign Missing"
    runs-on: ubuntu-latest
    needs: issues-labels-create
    steps:

      # ---------------------------------------------------------------------------------------
      #   checkout
      # ---------------------------------------------------------------------------------------

      - name: "‚òëÔ∏è Prepare"
        id: issues-labels-check-checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---------------------------------------------------------------------------------------
      #   Check if repo has labels currently added to issues
      # ---------------------------------------------------------------------------------------

      - name: üè∑Ô∏è Checking Issues
        id: issues-labels-check-run
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ADMINSERV_TOKEN_CL }}
          script: |

            /*
                Date/Time
            */

            const dateTimeformat = ( date ) =>
            {
                let month           = date.getMonth( ) + 1;
                month               = month.toString( ).padStart( 2, '0' );
                let day             = date.getDate( ).toString( ).padStart( 2, '0' );
                let year            = date.getFullYear( ).toString( ).padStart( 2, '0' );

                let hours           = date.getHours();
                let minutes         = date.getMinutes();
                let x               = hours >= 12 ? 'PM' : 'AM';
                hours               = hours % 12;
                hours               = hours ? hours : 12;
                minutes             = minutes.toString( ).padStart( 2, '0' );

                let mergeTime   = month + '.' + day + '.' + year + ' ' + hours + ':' + minutes + ' ' + x;

                return mergeTime;
            }

            /*
                Change last number ( 36 = hours )
            */

            const expireAfterMs     = 1000 * 60 * 60 * 36;        // milliseconds ( 36 hours )
            const curtime           = new Date( ).getTime( );     // 1711471510629
            const issues            = await github.rest.issues.listForRepo( { owner: context.repo.owner, repo: context.repo.repo, state: 'open' } );

            console.log( `  üì¶‚îÄ‚îÄ  Found ${issues.data.length} open issues` );

            for ( const issue of issues.data )
            {

                const author            = `${ issue.user.login }`;
                let date_UpdateDate     = new Date( `${ issue.updated_at }` ?? `${ issue.created_at }` );   // Tue Mar 26 2024 16:40:41 GMT+0000 (Coordinated Universal Time)
                date_UpdateDate.toISOString( )                                                              // Tue Mar 26 2024 16:40:41 GMT+0000 (Coordinated Universal Time) (string)

                let date_UpdateHuman    = dateTimeformat( date_UpdateDate ) + " UTC";                       // 03.26.2024 4:40 PM UTC
                const time_UpdateMs     = new Date( issue.updated_at ).getTime( );                          // 1711471241000

                //if ( curtime < time_UpdateMs + expireAfterMs ) continue;

                /*
                    Anything past this point is stale / to be closed
                */

                const timeline          = await github.rest.issues.listEventsForTimeline( { owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number } );
                // const labelEvent     = timeline.data.find( event => event.event === 'labeled' && event.label.name === 'status-stale' );

                /*
                    Get Issue Data
                */

                const add_labels        = issue.labels.map( label => label.name );

                let iss_title           = `${ issue.title }`;
                const iss_title_lc      = iss_title.toLowerCase( );

                let iss_body            = `${ issue.body }`;
                const iss_body_lc       = iss_body.toLowerCase( );

                console.log( `      ‚îî‚îÄ‚îÄ üìÅ ` + iss_title );
                console.log( `         ‚îî‚îÄ‚îÄ üìÑ Issue #${ issue.number } last updated on ${ date_UpdateHuman }` );
                console.log( `         ‚îî‚îÄ‚îÄ üìÑ ${add_labels}` );
                console.log( `\n\n` )

                /*
                    Keywords
                */

                const bug_words           = [ "bug", "broke", "issue", "fail" ];
                const feat_words          = [ "feature", "request", "add support" ];
                const urgn_words          = [ "urgent", "urgency", "emergency", "important", "critical" ];
                const road_words          = [ "roadmap", "road map", "planned" ];

                /*
                    Tags
                */

                const bug_tag             = `${{ env.PREFIX_BUG }}:`;
                const bug_lbl             = `${{ env.LABEL_BUG }}`;
                const feat_tag            = `${{ env.PREFIX_FEATURE }}:`;
                const feat_lbl            = `${{ env.LABEL_FEATURE }}`;
                const urgn_tag            = `${{ env.PREFIX_URGENT }}:`;
                const urgn_lbl            = `${{ env.LABEL_URGENT }}`;
                const road_tag            = `${{ env.PREFIX_ROADMAP }}:`;
                const road_lbl            = `${{ env.LABEL_ROADMAP }}`;

                /*
                    Label > Bugs
                */

                const bug_bIncWordT         = bug_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                /*
                    Find regex based phrases

                    Regex:
                        https://regex101.com/r/Z99Gnq/2
                */

                const bug_findWordList 	      = /^\b(?:I?\s*have\s*(?:a|an)\s*(?:issue|problem|bug))|(?:will\s*not\s*work)|(?:it\s*is\s*(?:broken|broke|stuck))|(?:found\s*(?:an?|the)\s*(?:bug|issue))|(?:can\s*I\s*fix\s*the\s*(?:bug|issue))|(?:(?:does not|doesn'?t|don'?t|won'?t|can'?t|can\s?not|will\s*not)\s*(?:work|load|function))|(?:it\s*(?:will\s?not|won'?t|can\s?not|can'?t))\s*(?:get|find)\s*the\s*(?:website|site|webpage|page)|(?:the\s*(?:window|frame)\s*is\s*(?:blank|white|empty|missing))\b$/igm;
                const bug_bFoundMatchTitle    = Boolean( bug_findWordList.test( iss_title ) );
                const bug_bFoundMatchBody     = Boolean( bug_findWordList.test( iss_body ) );

                /*
                    Do not change a title if the item starts with a PR: #

                    Regex:
                        https://regex101.com/r/JOrqbN/1
                */

                const bug_findPRTitle         = /^PR\s?#?(?:[0-9]*:)/igm;
                const bug_bFoundPRTitle       = Boolean( bug_findPRTitle.test( iss_title ) );

                /*
                    - Check if issue title matches the issue label "Bug:"
                    - Check if title contains word in containsList
                */

                if ( iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) || bug_bIncWordT || bug_bFoundMatchTitle || bug_bFoundMatchBody )
                {

                    add_labels.push( `${ bug_lbl }` );

                    if ( author === `${{ env.BOT_NAME_DEPENDABOT }}` )
                        core.info( `Skipping: Detected ${ author }` )

                    // Rename title to contain Bug:
                    if ( author !== `${{ env.BOT_NAME_DEPENDABOT }}` && !bug_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?bug\s*(.*?)\b/gi, '' );
                        title_new         		= title.replace( /^\s?fail\s*(.*?)\b/gi, '' );
                        title_new         		= title.replace( /^\s?issue\s*(.*?)\b/gi, '' );
                        iss_title             = `${ bug_tag } ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Features
                */

                const feat_bIncWordT      = feat_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                /*
                    Find regex based phrases

                    Regex:
                        https://regex101.com/r/fR1Hm6/1
                */

                const feat_findWordList 	    = /^(?:(?:request|include|see)\s*(?:an?|the?)\s*(?:feature|addon|addition|plugin))|(?:(?:add|see|get)\s*support\s*(?:for|with|of))|(?:can\s*we\s*get\s*(?:the|a)\s*(?:ability|feature))|(?:üí° Feature:)$/igm;
                const feat_bFoundMatchTitle     = Boolean( feat_findWordList.test( iss_title ) );
                const feat_bFoundMatchBody      = Boolean( feat_findWordList.test( iss_body ) );

                /*
                    Do not change a title if the item starts with a PR: #

                    Regex:
                        https://regex101.com/r/JOrqbN/1
                */

                const feat_findPRTitle          = /^PR\s?#?(?:[0-9]*:)/igm;
                const feat_bFoundPRTitle        = Boolean( feat_findPRTitle.test( iss_title ) );

                /*
                    - Check if issue title matches the issue label "Feature:"
                    - Check if title contains word in containsList
                */

                if ( iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) || feat_bIncWordT || feat_bFoundMatchTitle || feat_bFoundMatchBody )
                {

                    add_labels.push( `${ feat_lbl }` );

                    if ( author === `${{ env.BOT_NAME_DEPENDABOT }}` )
                        core.info( `Skipping: Detected ${ author }` )

                    // Rename title to contain Feature:
                    if ( author !== `${{ env.BOT_NAME_DEPENDABOT }}` && !feat_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?feature\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?request\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?add(.*?)\s?feature\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?add(.*?)\s?support\s*(.*?)\b/gi, '' );
                        iss_title             = `${ feat_tag } ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Urgent
                */

                const urgn_bIncWordT      = urgn_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                /*
                    Find regex based phrases

                    Regex:
                        https://regex101.com/r/eE9tJX/2
                */

                const urgn_findWordList       = /(?:(?:this)?is\s*a?n?\s*?(?:emergency|urgent|important|vital|acute|crucial|grave|pressing|serious|top.?priority|high.?priority))|(?:reply|respond|answer|write|address)\s*(?:immediate|quick|asap|urgent|now|fast|(?:as)?\s*(?:soon|quick|immediate|fast))(?:ly)?|(?:need\s*(?:help|support|fixed|answer|reply|response)!)|(?:emergency|critical|urgen(?:t|cy)|high.?priority)/igm;
                const urgn_bFoundMatchTitle   = Boolean( urgn_findWordList.test( iss_title ) );
                const urgn_bFoundMatchBody    = Boolean( urgn_findWordList.test( iss_body ) );

                /*
                    Do not change a title if the item starts with a PR: #

                    Regex:
                        https://regex101.com/r/JOrqbN/1
                */

                const urgn_findPRTitle          = /^PR\s?#?(?:[0-9]*:)/igm;
                const urgn_bFoundPRTitle        = Boolean( urgn_findPRTitle.test( iss_title ) );

                /*
                    - Check if issue title matches the issue label "Urgent:"
                    - Check if title contains word in containsList
                */

                if ( iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) || urgn_bIncWordT || urgn_bFoundMatchTitle || urgn_bFoundMatchBody )
                {

                    add_labels.push( `${ urgn_lbl }` );

                    if ( author === `${{ env.BOT_NAME_DEPENDABOT }}` )
                        core.info( `Skipping: Detected ${ author }` )

                    // Rename title to contain Urgent:
                    if ( author !== `${{ env.BOT_NAME_DEPENDABOT }}` && !urgn_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?emergency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgent\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?important\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?critical\s*(.*?)\b/gi, '' );
                        iss_title             = `${ urgn_tag } ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                    Label > Roadmap
                */

                const road_bIncWordT      = road_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                /*
                    Find regex based phrases
                    Roadmap requires headers #Summary and #Proposal | #Objective

                    Regex:
                        https://regex101.com/r/ucajBZ/1
                */

                const road_findWordList 	      = /#\s*Summary[\S\s]+#\s*(?:Proposal|Objective)[^\]]+/igm;
                const road_bFoundMatchTitle     = Boolean( road_findWordList.test( iss_title ) );
                const road_bFoundMatchBody      = Boolean( road_findWordList.test( iss_body ) );

                /*
                    Do not change a title if the item starts with a PR: #

                    Regex:
                        https://regex101.com/r/JOrqbN/1
                */

                const road_findPRTitle          = /^PR\s?#?(?:[0-9]*:)/igm;
                const road_bFoundPRTitle        = Boolean( road_findPRTitle.test( iss_title ) );

                /*
                    - Check if issue title matches the issue label "Roadmap:"
                    - Check if title contains word in containsList
                */

                if ( iss_title_lc.startsWith( road_tag.toLowerCase( ) ) || road_bIncWordT || road_bFoundMatchTitle || road_bFoundMatchBody )
                {

                    add_labels.push( `${ road_lbl }` );

                    if ( author === `${{ env.BOT_NAME_DEPENDABOT }}` )
                        core.info( `Skipping: Detected ${ author }` )

                    // Rename title to contain Roadmap:
                    if ( author !== `${{ env.BOT_NAME_DEPENDABOT }}` && !road_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                    {
                        const title           = issue.title;
                        let title_new         = title.replace( /^\s?emergency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgent\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?urgency\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?important\s*(.*?)\b/gi, '' );
                        title_new             = title.replace( /^\s?critical\s*(.*?)\b/gi, '' );
                        iss_title             = `${ road_tag } ${ title_new }`;
                    }

                    await github.rest.issues.update(
                    {
                        owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                        title: `${ iss_title }`, labels: add_labels
                    } );
                }

                /*
                await github.rest.issues.update(
                {
                    owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                    state: 'closed', state_reason: 'not planned'
                } );
                */
            }

  # ---------------------------------------------------------------------------------------
  #   Check Issues
  # ---------------------------------------------------------------------------------------

  issues-stale-check:
    name: "üí§ Check ‚Ä∫ Stale"
    runs-on: ubuntu-latest
    needs:
      - issues-labels-create
      - issues-labels-check
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:

  # ---------------------------------------------------------------------------------------
  #   Check Stale Issues
  # ---------------------------------------------------------------------------------------

    - name: "üí§ Stale ‚Ä∫ Check Condition"
      uses: actions/stale@v9
      id: issues-stale-check-run
      with:
        repo-token: ${{ secrets.ADMINSERV_TOKEN }}
        stale-issue-message: |
          ‚ö†Ô∏è It looks like there hasn't been any recent updates on this
          issue.  If you created this issue and no longer consider it
          open, then please login to github and close the issue.

          If there is no further activity on this issue, it will be
          automatically closed in the next few days.

          ---

          <sub>I am a bot reaching out to you with an automated response.</sub>

        stale-issue-label: 'Status êÑÇ Stale'
        close-issue-label: 'Status êÑÇ '
        exempt-issue-labels: 'feature,Type ‚ó¶ Feature,bug,Type ‚ó¶ Bug'
        days-before-stale: 30
        days-before-close: 7
        days-before-pr-stale: -1
        days-before-pr-close: -1

  # ---------------------------------------------------------------------------------------
  #   Lock items which have been closed for a long time
  # ---------------------------------------------------------------------------------------

  issues-lock-check:
    name: "üîí Check ‚Ä∫ Inactive"
    runs-on: ubuntu-latest
    needs:
      - issues-labels-create
      - issues-labels-check
    steps:

    - name: "üîí Lock ‚Ä∫ Inactives"
      uses: dessant/lock-threads@v5
      id: issues-lock-check-run
      with:
        add-pr-labels: 'Status ‚ÜØ Locked'
        add-issue-labels: 'Status ‚ÜØ Locked'
        github-token: ${{ secrets.ADMINSERV_TOKEN }}
        issue-inactive-days: '180'
        issue-lock-reason: 'resolved'
        pr-inactive-days: '365'
        pr-lock-reason: 'resolved'
