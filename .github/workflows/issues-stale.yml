# #
#   @type               github workflow
#   @desc               creates repository labels if they are not yet installed
#                         issues marked as stale after 30 days, given tag Status êÑÇ Stale
#                         inactive issues closed after 180 days, given tag Status êÑÇ Locked
#                         inactive pr closed after 365 days, given tag Status êÑÇ Locked
#                         issues marked stale after 30 days, given tag Status êÑÇ Stale
#                         issues marked closed 7 days after being marked stale, given tag Status êÑÇ Autoclosed
#   @author             Aetherinox
#   @url                https://github.com/Aetherinox
#
#   This Github action must be activated manually.  This workflow script will do the
#   following:
#
#       - Scan issues / pull requests and make sure they have properly assigned labels:
#           - `Bug`
#           - `Feature`
#           - `Urgent`
#           - `Roadmap`
#
#       - Workflow script will then scan each pr or issue and mark them as `Stale`
#         if they haven't had any replies in 30 days.
#
#       - Workflow will `autoclose` pr or issues which haven't had action in `365 days`.
# #

name: "üé´ Issues ‚Ä∫ Stale"
run-name: "üé´ Issues ‚Ä∫ Stale"

# #
#   triggers
# #

on:
    workflow_dispatch:
    schedule:
        - cron: "0 0 * * *"

# #
#   environment variables
# #

env:
    PREFIX_BUG:           "Bug"
    PREFIX_DEPENDENCY:    "Dependency"
    PREFIX_DOCS:          "Docs"
    PREFIX_FEATURE:       "Feature"
    PREFIX_GIT:           "Git Action"
    PREFIX_PR:            "PR"
    PREFIX_ROADMAP:       "Roadmap"
    PREFIX_INTERNAL:      "Internal"
    PREFIX_URGENT:        "Urgent"

    LABEL_BUG:            "Type ‚ó¶ Bug"
    LABEL_DEPENDENCY:     "Type ‚ó¶ Dependency"
    LABEL_DOCS:           "Type ‚ó¶ Docs"
    LABEL_FEATURE:        "Type ‚ó¶ Feature"
    LABEL_GIT:            "Type ‚ó¶ Git Action"
    LABEL_PR:             "Type ‚ó¶ Pull Request"
    LABEL_ROADMAP:        "Type ‚ó¶ Roadmap"
    LABEL_INTERNAL:       "Type ‚ó¶ Internal"
    LABEL_URGENT:         "‚ö† Urgent"

    BOT_NAME_1:           AdminServ
    BOT_NAME_2:           AdminServX
    BOT_NAME_3:           EuropaServ
    BOT_NAME_DEPENDABOT:  dependabot[bot]
    LABELS_JSON: |
      [
          { "name": "AC ‚Ä∫ Changes Made",           "color": "8F1784", "description": "Requested changes have been made and are pending a re-scan" },
          { "name": "AC ‚Ä∫ Changes Required",       "color": "8F1784", "description": "Requires changes to be made to the package before being accepted" },
          { "name": "AC ‚Ä∫ Failed",                 "color": "a61f2d", "description": "Autocheck failed to run through a complete cycle, requires investigation" },
          { "name": "AC ‚Ä∫ Needs Rebase",           "color": "8F1784", "description": "Due to the permissions on the requesting repo, this pull request must be rebased by the author" },
          { "name": "AC ‚Ä∫ Passed",                 "color": "146b4a", "description": "Ready to be reviewed" },
          { "name": "AC ‚Ä∫ Review Required",        "color": "8F1784", "description": "PR needs to be reviewed by another person, after the requested changes have been made" },
          { "name": "AC ‚Ä∫ Security Warning",       "color": "761620", "description": "Does not conform to developer policies, or includes potentially dangerous code" },
          { "name": "AC ‚Ä∫ Skipped Scan",           "color": "8F1784", "description": "Author has skipped code scan" },
          { "name": "Status êÑÇ Duplicate",          "color": "75536b", "description": "Issue or pull request already exists" },
          { "name": "Status êÑÇ Accepted",            "color": "2e7539", "description": "This pull request has been accepted" },
          { "name": "Status êÑÇ Autoclosed",          "color": "3E0915", "description": "Originally stale and was autoclosed for no activity" },
          { "name": "Status êÑÇ Denied",              "color": "ba4058", "description": "Pull request has been denied" },
          { "name": "Status êÑÇ Locked",              "color": "550F45", "description": "Automatically locked by AdminServ for a prolonged period of inactivity" },
          { "name": "Status êÑÇ Need Info",           "color": "2E3C4C", "description": "Not enough information to resolve" },
          { "name": "Status êÑÇ No Action",           "color": "030406", "description": "Closed without any action being taken" },
          { "name": "Status êÑÇ Pending",             "color": "984b12", "description": "Pending pull request" },
          { "name": "Status êÑÇ Released",            "color": "1b6626", "description": "Issues or PR has been implemented and is now live" },
          { "name": "Status êÑÇ Reopened",            "color": "8a6f14", "description": "A previously closed PR which has been re-opened" },
          { "name": "Status êÑÇ Review",              "color": "9e1451", "description": "Currently pending review" },
          { "name": "Status êÑÇ Stale",               "color": "928282", "description": "Has not had any activity in over 30 days" },
          { "name": "Type ‚ó¶ Bug",                   "color": "9a2c2c", "description": "Something isn't working" },
          { "name": "Type ‚ó¶ Dependency",            "color": "243759", "description": "Item is associated to dependency" },
          { "name": "Type ‚ó¶ Docs",                  "color": "0e588d", "description": "Improvements or modifications to docs" },
          { "name": "Type ‚ó¶ Feature",               "color": "3c4e93", "description": "Feature request" },
          { "name": "Type ‚ó¶ Git Action",            "color": "030406", "description": "GitHub Action / workflow" },
          { "name": "Type ‚ó¶ Pull Request",          "color": "8F1784", "description": "Normal pull request" },
          { "name": "Type ‚ó¶ Roadmap",               "color": "8F1784", "description": "Feature or bug currently planned for implementation" },
          { "name": "Type ‚ó¶ Internal",              "color": "A51994", "description": "Assigned items are for internal developer use" },
          { "name": "Build ‚ó¶ Desktop",              "color": "c7ca4a", "description": "Specific to desktop" },
          { "name": "Build ‚ó¶ Linux",                "color": "c7ca4a", "description": "Specific to Linux" },
          { "name": "Build ‚ó¶ MacOS",                "color": "c7ca4a", "description": "Specific to MacOS" },
          { "name": "Build ‚ó¶ Mobile",               "color": "c7ca4a", "description": "Specific to mobile" },
          { "name": "Build ‚ó¶ Web",                  "color": "c7ca4a", "description": "Specific to web" },
          { "name": "Build ‚ó¶ Windows",              "color": "c7ca4a", "description": "Specific to Windows" },
          { "name": "‚Ä∫ API",                        "color": "F99B50", "description": "Plugin API, CLI, browser JS API" },
          { "name": "‚Ä∫ Auto-type",                  "color": "9141E0", "description": "Auto-type functionality in desktop apps" },
          { "name": "‚Ä∫ Browser",                    "color": "9141E0", "description": "Browser plugins and passing data to <=> from app" },
          { "name": "‚Ä∫ Customization",              "color": "E3F0FC", "description": "Customizations: plugins, themes, configs" },
          { "name": "‚Ä∫ Design",                     "color": "FA70DE", "description": "Design related queries" },
          { "name": "‚Ä∫ Dist",                       "color": "FA70DE", "description": "Installers and other forms of software distribution" },
          { "name": "‚Ä∫ Enterprise",                 "color": "11447a", "description": "Issues about collaboration, administration, and so on" },
          { "name": "‚Ä∫ Hardware",                   "color": "5a7503", "description": "YubiKey, other tokens, biometrics" },
          { "name": "‚Ä∫ Import/Export",              "color": "F5FFCC", "description": "Import from and export to different file formats" },
          { "name": "‚Ä∫ Improvement",                "color": "185c98", "description": "Enhance an existing feature" },
          { "name": "‚Ä∫ Performance",                "color": "006b75", "description": "Web and desktop performance issues" },
          { "name": "‚Ä∫ Plugin Request",             "color": "FCE9CA", "description": "Requested changes should be implemented as a plugin" },
          { "name": "‚Ä∫ Security",                   "color": "F75D39", "description": "Security issues" },
          { "name": "‚Ä∫ Self-Hosting",               "color": "fad8c7", "description": "Self-hosting installations and configs" },
          { "name": "‚Ä∫ Storage",                    "color": "5319e7", "description": "Storage providers: Dropbox, Google, WebDAV, etc." },
          { "name": "‚Ä∫ Updater",                    "color": "1BADDE", "description": "Auto-updater issues" },
          { "name": "‚Ä∫ UX",                         "color": "1BADDE", "description": "UX and usability" },
          { "name": "‚Ä∫ Website",                    "color": "fef2c0", "description": "Website related issues" },
          { "name": "‚ö† Urgent",                     "color": "a8740e", "description": "Requires urgent attention" },
          { "name": "‚ö† Announcement",               "color": "DB4712", "description": "Announcements" },
          { "name": "üì∞ Progress Report",           "color": "392297", "description": "Development updates" },
          { "name": "üì¶ Release",                   "color": "277542", "description": "Release announcements" },
          { "name": "‚úîÔ∏è Poll",                      "color": "972255", "description": "Community polls" },
          { "name": "‚ùî Question",                  "color": "FFFFFF", "description": "All questions" }
      ]

# #
#   jobs
# #

jobs:

    # #
    #   Job [ Verify / Create Labels ]
    #
    #   This job will ensure you have labels already created in your repo.
    #   All labels come from the JSON table LABELS_JSON.
    # #

    job-labels-create:
        name: >-
            üé´ Labels ‚Ä∫ Verify Existing
        runs-on: ubuntu-latest
        steps:

            # #
            #   [ Create Labels ] Start
            # #

            - name: >-
                  ‚úÖ Start
              id: task_label_create_start
              run: |
                  echo "Assigning labels and assignees"

            # #
            #   [ Create Labels ] Checkout
            # #

            - name: >-
                  ‚òëÔ∏è Checkout
              id: task_label_create_checkout
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            # #
            #   [ Create Labels ] Verify Existing Labels
            # #

            - name: >-
                  üè∑Ô∏è Verify Existing Labels
              id: task_label_create_verify
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.ADMINSERV_TOKEN_CL }}
                  script: |
                      const labels = JSON.parse( process.env.LABELS_JSON );
                      for ( const label of labels )
                      {
                          try
                          {
                              await github.rest.issues.createLabel(
                              {
                                  owner:        context.repo.owner,
                                  repo:         context.repo.repo,
                                  name:         label.name,
                                  description:  label.description || '',
                                  color:        label.color
                              });
                          }
                          catch ( err )
                          {
                              if ( err.status === 422 )
                              {
                                  console.log( `Label '${label.name}' already exists. Skipping.` );
                              }
                              else
                              {
                                  console.error( `Error creating label '${label.name}': ${err}` );
                              }
                          }
                      }

    # #
    #   Job [ Check Labels ]
    #
    #   Runs through all submissions to check for ones that have not been properly labeled
    #       - Bug
    #       - Feature
    #       - Urgent
    #       - Roadmap
    # #

    job-issues-nolabel:
        name: >-
            üé´ Labels ‚Ä∫ Assign Missing
        runs-on: ubuntu-latest
        needs: job-labels-create
        steps:

            # #
            #   [ Check Labels ] Checkout
            # #

            - name: "‚òëÔ∏è Prepare"
              id: task_issues_nolabel_prepare
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            # #
            #   [ Check Labels ] Check
            #   Check if repo has labels currently added to issues
            # #

            - name: üè∑Ô∏è Checking Issues
              id: task_issues_nolabel_run
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.ADMINSERV_TOKEN_CL }}
                  script: |

                    /*
                        Date/Time
                    */

                    const dateTimeformat = ( date ) =>
                    {
                        let month           = date.getMonth( ) + 1;
                        month               = month.toString( ).padStart( 2, '0' );
                        let day             = date.getDate( ).toString( ).padStart( 2, '0' );
                        let year            = date.getFullYear( ).toString( ).padStart( 2, '0' );

                        let hours           = date.getHours();
                        let minutes         = date.getMinutes();
                        let x               = hours >= 12 ? 'PM' : 'AM';
                        hours               = hours % 12;
                        hours               = hours ? hours : 12;
                        minutes             = minutes.toString( ).padStart( 2, '0' );

                        let mergeTime   = month + '.' + day + '.' + year + ' ' + hours + ':' + minutes + ' ' + x;

                        return mergeTime;
                    }

                    /*
                        Change last number ( 36 = hours )
                    */

                    const expireAfterMs         = 1000 * 60 * 60 * 36;        // milliseconds ( 36 hours )
                    const curtime               = new Date( ).getTime( );     // 1711471510629
                    const issues                = await github.rest.issues.listForRepo( { owner: context.repo.owner, repo: context.repo.repo, state: 'open' } );

                    console.log( `  üì¶‚îÄ‚îÄ  Found ${issues.data.length} open issues` );

                    for ( const issue of issues.data )
                    {

                        const author            = `${ issue.user.login }`;
                        let date_UpdateDate     = new Date( `${ issue.updated_at }` ?? `${ issue.created_at }` );   // Tue Mar 26 2024 16:40:41 GMT+0000 (Coordinated Universal Time)
                        date_UpdateDate.toISOString( )                                                              // Tue Mar 26 2024 16:40:41 GMT+0000 (Coordinated Universal Time) (string)

                        let date_UpdateHuman    = dateTimeformat( date_UpdateDate ) + " UTC";                       // 03.26.2024 4:40 PM UTC
                        const time_UpdateMs     = new Date( issue.updated_at ).getTime( );                          // 1711471241000

                        //if ( curtime < time_UpdateMs + expireAfterMs ) continue;

                        /*
                            Anything past this point is stale / to be closed
                        */

                        const timeline          = await github.rest.issues.listEventsForTimeline( { owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number } );
                        // const labelEvent     = timeline.data.find( event => event.event === 'labeled' && event.label.name === 'status-stale' );

                        /*
                            Get Issue Data
                        */

                        const add_labels        = issue.labels.map( label => label.name );

                        let iss_title           = `${ issue.title }`;
                        const iss_title_lc      = iss_title.toLowerCase( );

                        let iss_body            = `${ issue.body }`;
                        const iss_body_lc       = iss_body.toLowerCase( );

                        console.log( `      ‚îî‚îÄ‚îÄ üìÅ ` + iss_title );
                        console.log( `         ‚îî‚îÄ‚îÄ üìÑ Issue #${ issue.number } last updated on ${ date_UpdateHuman }` );
                        console.log( `         ‚îî‚îÄ‚îÄ üìÑ ${add_labels}` );
                        console.log( `\n\n` )

                        /*
                            Keywords
                        */

                        const bug_words           = [ "bug", "broke", "issue", "fail" ];
                        const feat_words          = [ "feature", "request", "add support" ];
                        const urgn_words          = [ "urgent", "urgency", "emergency", "important", "critical" ];
                        const road_words          = [ "roadmap", "road map", "planned" ];

                        /*
                            Tags
                        */

                        const bug_tag             = `${{ env.PREFIX_BUG }}:`;
                        const bug_lbl             = `${{ env.LABEL_BUG }}`;
                        const feat_tag            = `${{ env.PREFIX_FEATURE }}:`;
                        const feat_lbl            = `${{ env.LABEL_FEATURE }}`;
                        const urgn_tag            = `${{ env.PREFIX_URGENT }}:`;
                        const urgn_lbl            = `${{ env.LABEL_URGENT }}`;
                        const road_tag            = `${{ env.PREFIX_ROADMAP }}:`;
                        const road_lbl            = `${{ env.LABEL_ROADMAP }}`;

                        /*
                            Label > Bugs
                        */

                        const bug_bIncWordT             = bug_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                        /*
                            Find regex based phrases

                            Regex:
                                https://regex101.com/r/Z99Gnq/2
                        */

                        const bug_findWordList 	        = /^\b(?:I?\s*have\s*(?:a|an)\s*(?:issue|problem|bug))|(?:will\s*not\s*work)|(?:it\s*is\s*(?:broken|broke|stuck))|(?:found\s*(?:an?|the)\s*(?:bug|issue))|(?:can\s*I\s*fix\s*the\s*(?:bug|issue))|(?:(?:does not|doesn'?t|don'?t|won'?t|can'?t|can\s?not|will\s*not)\s*(?:work|load|function))|(?:it\s*(?:will\s?not|won'?t|can\s?not|can'?t))\s*(?:get|find)\s*the\s*(?:website|site|webpage|page)|(?:the\s*(?:window|frame)\s*is\s*(?:blank|white|empty|missing))\b$/igm;
                        const bug_bFoundMatchTitle      = Boolean( bug_findWordList.test( iss_title ) );
                        const bug_bFoundMatchBody       = Boolean( bug_findWordList.test( iss_body ) );

                        /*
                            Do not change a title if the item starts with a PR: #

                            Regex:
                                https://regex101.com/r/JOrqbN/1
                        */

                        const bug_findPRTitle           = /^PR\s?#?(?:[0-9]*:)/igm;
                        const bug_bFoundPRTitle         = Boolean( bug_findPRTitle.test( iss_title ) );

                        /*
                            - Check if issue title matches the issue label "Bug:"
                            - Check if title contains word in containsList
                        */

                        if ( iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) || bug_bIncWordT || bug_bFoundMatchTitle || bug_bFoundMatchBody )
                        {

                            add_labels.push( `${ bug_lbl }` );

                            if ( author === `${{ env.BOT_NAME_DEPENDABOT }}` )
                                core.info( `Skipping: Detected ${ author }` )

                            // Rename title to contain Bug:
                            if ( author !== `${{ env.BOT_NAME_DEPENDABOT }}` && !bug_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                            {
                                const title             = issue.title;
                                let title_new           = title.replace( /^\s?bug\s*(.*?)\b/gi, '' );
                                title_new         		  = title.replace( /^\s?fail\s*(.*?)\b/gi, '' );
                                title_new         		  = title.replace( /^\s?issue\s*(.*?)\b/gi, '' );
                                iss_title               = `${ bug_tag } ${ title_new }`;
                            }

                            await github.rest.issues.update(
                            {
                                owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                                title: `${ iss_title }`, labels: add_labels
                            } );
                        }

                        /*
                            Label > Features
                        */

                        const feat_bIncWordT            = feat_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                        /*
                            Find regex based phrases

                            Regex:
                                https://regex101.com/r/fR1Hm6/1
                        */

                        const feat_findWordList 	      = /^(?:(?:request|include|see)\s*(?:an?|the?)\s*(?:feature|addon|addition|plugin))|(?:(?:add|see|get)\s*support\s*(?:for|with|of))|(?:can\s*we\s*get\s*(?:the|a)\s*(?:ability|feature))|(?:üí° Feature:)$/igm;
                        const feat_bFoundMatchTitle     = Boolean( feat_findWordList.test( iss_title ) );
                        const feat_bFoundMatchBody      = Boolean( feat_findWordList.test( iss_body ) );

                        /*
                            Do not change a title if the item starts with a PR: #

                            Regex:
                                https://regex101.com/r/JOrqbN/1
                        */

                        const feat_findPRTitle          = /^PR\s?#?(?:[0-9]*:)/igm;
                        const feat_bFoundPRTitle        = Boolean( feat_findPRTitle.test( iss_title ) );

                        /*
                            - Check if issue title matches the issue label "Feature:"
                            - Check if title contains word in containsList
                        */

                        if ( iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) || feat_bIncWordT || feat_bFoundMatchTitle || feat_bFoundMatchBody )
                        {

                            add_labels.push( `${ feat_lbl }` );

                            if ( author === `${{ env.BOT_NAME_DEPENDABOT }}` )
                                core.info( `Skipping: Detected ${ author }` )

                            // Rename title to contain Feature:
                            if ( author !== `${{ env.BOT_NAME_DEPENDABOT }}` && !feat_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                            {
                                const title             = issue.title;
                                let title_new           = title.replace( /^\s?feature\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?request\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?add(.*?)\s?feature\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?add(.*?)\s?support\s*(.*?)\b/gi, '' );
                                iss_title               = `${ feat_tag } ${ title_new }`;
                            }

                            await github.rest.issues.update(
                            {
                                owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                                title: `${ iss_title }`, labels: add_labels
                            } );
                        }

                        /*
                            Label > Urgent
                        */

                        const urgn_bIncWordT            = urgn_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                        /*
                            Find regex based phrases

                            Regex:
                                https://regex101.com/r/eE9tJX/2
                        */

                        const urgn_findWordList         = /(?:(?:this)?is\s*a?n?\s*?(?:emergency|urgent|important|vital|acute|crucial|grave|pressing|serious|top.?priority|high.?priority))|(?:reply|respond|answer|write|address)\s*(?:immediate|quick|asap|urgent|now|fast|(?:as)?\s*(?:soon|quick|immediate|fast))(?:ly)?|(?:need\s*(?:help|support|fixed|answer|reply|response)!)|(?:emergency|critical|urgen(?:t|cy)|high.?priority)/igm;
                        const urgn_bFoundMatchTitle     = Boolean( urgn_findWordList.test( iss_title ) );
                        const urgn_bFoundMatchBody      = Boolean( urgn_findWordList.test( iss_body ) );

                        /*
                            Do not change a title if the item starts with a PR: #

                            Regex:
                                https://regex101.com/r/JOrqbN/1
                        */

                        const urgn_findPRTitle          = /^PR\s?#?(?:[0-9]*:)/igm;
                        const urgn_bFoundPRTitle        = Boolean( urgn_findPRTitle.test( iss_title ) );

                        /*
                            - Check if issue title matches the issue label "Urgent:"
                            - Check if title contains word in containsList
                        */

                        if ( iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) || urgn_bIncWordT || urgn_bFoundMatchTitle || urgn_bFoundMatchBody )
                        {

                            add_labels.push( `${ urgn_lbl }` );

                            if ( author === `${{ env.BOT_NAME_DEPENDABOT }}` )
                                core.info( `Skipping: Detected ${ author }` )

                            // Rename title to contain Urgent:
                            if ( author !== `${{ env.BOT_NAME_DEPENDABOT }}` && !urgn_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                            {
                                const title             = issue.title;
                                let title_new           = title.replace( /^\s?emergency\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?urgent\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?urgency\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?important\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?critical\s*(.*?)\b/gi, '' );
                                iss_title               = `${ urgn_tag } ${ title_new }`;
                            }

                            await github.rest.issues.update(
                            {
                                owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                                title: `${ iss_title }`, labels: add_labels
                            } );
                        }

                        /*
                            Label > Roadmap
                        */

                        const road_bIncWordT      = road_words.some( s => s.includes( iss_title_lc ) || iss_title_lc.includes( s ) );

                        /*
                            Find regex based phrases
                            Roadmap requires headers #Summary and #Proposal | #Objective

                            Regex:
                                https://regex101.com/r/ucajBZ/1
                        */

                        const road_findWordList 	        = /#\s*Summary[\S\s]+#\s*(?:Proposal|Objective)[^\]]+/igm;
                        const road_bFoundMatchTitle       = Boolean( road_findWordList.test( iss_title ) );
                        const road_bFoundMatchBody        = Boolean( road_findWordList.test( iss_body ) );

                        /*
                            Do not change a title if the item starts with a PR: #

                            Regex:
                                https://regex101.com/r/JOrqbN/1
                        */

                        const road_findPRTitle            = /^PR\s?#?(?:[0-9]*:)/igm;
                        const road_bFoundPRTitle          = Boolean( road_findPRTitle.test( iss_title ) );

                        /*
                            - Check if issue title matches the issue label "Roadmap:"
                            - Check if title contains word in containsList
                        */

                        if ( iss_title_lc.startsWith( road_tag.toLowerCase( ) ) || road_bIncWordT || road_bFoundMatchTitle || road_bFoundMatchBody )
                        {

                            add_labels.push( `${ road_lbl }` );

                            if ( author === `${{ env.BOT_NAME_DEPENDABOT }}` )
                                core.info( `Skipping: Detected ${ author }` )

                            // Rename title to contain Roadmap:
                            if ( author !== `${{ env.BOT_NAME_DEPENDABOT }}` && !road_bFoundPRTitle && !iss_title_lc.startsWith( bug_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( feat_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( urgn_tag.toLowerCase( ) ) && !iss_title_lc.startsWith( road_tag.toLowerCase( ) ) )
                            {
                                const title             = issue.title;
                                let title_new           = title.replace( /^\s?emergency\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?urgent\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?urgency\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?important\s*(.*?)\b/gi, '' );
                                title_new               = title.replace( /^\s?critical\s*(.*?)\b/gi, '' );
                                iss_title               = `${ road_tag } ${ title_new }`;
                            }

                            await github.rest.issues.update(
                            {
                                owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                                title: `${ iss_title }`, labels: add_labels
                            } );
                        }

                        /*
                        await github.rest.issues.update(
                        {
                            owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number,
                            state: 'closed', state_reason: 'not planned'
                        } );
                        */
                    }

    # #
    #   Job [ Stale Issues ]
    # #

    job-issues-stale:
        name: >-
            üí§ Check ‚Ä∫ Stale
        runs-on: ubuntu-latest
        needs:
            - job-labels-create
            - job-issues-nolabel
        permissions:
            contents: write
            issues: write
            pull-requests: write
        steps:

            # #
            #   [ Stale Issues ] Check Condition
            # #

          - name: "üí§ Stale ‚Ä∫ Check Condition"
            uses: actions/stale@v9
            id: task_issues_stale_run
            with:
                repo-token: ${{ secrets.ADMINSERV_TOKEN }}
                stale-issue-message: |
                    ‚ö†Ô∏è It looks like there hasn't been any recent updates on this
                    issue.  If you created this issue and no longer consider it
                    open, then please login to github and close the issue.

                    If there is no further activity on this issue, it will be
                    automatically closed in the next few days.

                    ---

                    <sub>I am a bot reaching out to you with an automated response.</sub>
                stale-issue-label: 'Status êÑÇ Stale'
                close-issue-label: 'Status êÑÇ Autoclosed'
                exempt-issue-labels: 'feature,Type ‚ó¶ Feature,bug,Type ‚ó¶ Bug'
                days-before-stale: 30
                days-before-close: 7
                days-before-pr-stale: -1
                days-before-pr-close: -1

    # #
    #   Job [ Lock Issues ]
    # #

    job-issues-lock:
        name: >-
            üîí Check ‚Ä∫ Inactive
        runs-on: ubuntu-latest
        needs:
            - job-labels-create
            - job-issues-nolabel
        steps:

            # #
            #   [ Lock Issues ] Look for inactives
            # #

            - name: "üîí Lock ‚Ä∫ Inactives"
              uses: dessant/lock-threads@v5
              id: task_issues_lock_run
              with:
                  add-pr-labels: 'Status êÑÇ Locked'
                  add-issue-labels: 'Status êÑÇ Locked'
                  github-token: ${{ secrets.ADMINSERV_TOKEN }}
                  issue-inactive-days: '180'
                  issue-lock-reason: 'resolved'
                  pr-inactive-days: '365'
                  pr-lock-reason: 'resolved'
